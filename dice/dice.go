package dice

import (
  "math"
  "probability"
)


type DieRolls struct {
  Die int
  Rolls int
  Min int
  Max int
  Quartile25 int
  Quartile50 int
  Quartile75 int
}

// Calculates the min, max and quartile values that can be generated by
// rolling a die rolls times.
//
func CalculateProbabilities(rolls, die int) *DieRolls {
  dieRolls := new(DieRolls)
  dieRolls.Rolls = rolls
  dieRolls.Die = die
  dieRolls.Min = rolls
  dieRolls.Max = die * rolls

  cache := make(map[string]int64)

  totalRolls := math.Pow(float64(die), float64(rolls))
  quarterRolls := int64(math.Floor(totalRolls * .25))
  halfRolls := int64(math.Floor(totalRolls * .5))
  thirdQuarterRolls := int64(math.Floor(totalRolls * .75))
  
  totalCount := int64(0)
  for value := dieRolls.Min; value <= dieRolls.Max; value++ {
    totalCount += possibilityCount(value, rolls, die, cache)
    if dieRolls.Quartile25 == 0 && totalCount > quarterRolls {
      dieRolls.Quartile25 = value
    } else if dieRolls.Quartile50 == 0 && totalCount > halfRolls {
      dieRolls.Quartile50 = value
    } else if dieRolls.Quartile75 == 0 && totalCount > thirdQuarterRolls {
      dieRolls.Quartile75 = value
    }
  }

  return dieRolls
}


func likelihood(p, n, s int, cache map[string]int64) float64 {
  totalRolls := math.Pow(float64(s), float64(n))
  count := possibilityCount(p, n, s, cache)

  return float64(count) / totalRolls
}

func possibilityCount(p, n, s int, cache map[string]int64) int64 {
  // See http://mathworld.wolfram.com/Dice.html for an explanation of this
  kMax := int(math.Floor(float64(p - n) / float64(s)))
  
  total := int64(0)
  sign := int64(-1)
  for k := int(0); k <= kMax; k++ {
    sign *= int64(-1)
    left := probability.ChooseHelper(n, k, cache)
    right := probability.ChooseHelper((p - s*k - 1), n - 1, cache)

    term := sign * left * right
    total += term
  }

  return total
}

