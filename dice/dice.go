package dice

import (
	"fmt"
	"github.com/Encinarus/Go-Dice/probability"
	"math"
)

type DieRolls struct {
	Roll string
	Min  int
	Max  int
	Avg  float64

	Rolls []float64
}

// Calculates the min, max and quartile values that can be generated by
// rolling a die rolls times.
//
func CalculateProbabilities(rolls, die int) *DieRolls {
	dieRolls := new(DieRolls)
	dieRolls.Roll = fmt.Sprintf("%dd%d", rolls, die)
	dieRolls.Min = rolls
	dieRolls.Max = die * rolls
	dieRolls.Avg = float64(dieRolls.Min+dieRolls.Max) / 2.0
	dieRolls.Rolls = make([]float64, dieRolls.Max-dieRolls.Min+1)

	cache := make(map[string]int64)

	totalRolls := math.Pow(float64(die), float64(rolls))

	for value := dieRolls.Min; value <= dieRolls.Max; value++ {
		count := possibilityCount(value, rolls, die, cache)

		dieRolls.Rolls[value-dieRolls.Min] = float64(count) / totalRolls
	}

	return dieRolls
}

func likelihood(p, n, s int, cache map[string]int64) float64 {
	totalRolls := math.Pow(float64(s), float64(n))
	count := possibilityCount(p, n, s, cache)

	return float64(count) / totalRolls
}

func possibilityCount(p, n, s int, cache map[string]int64) int64 {
	// See http://mathworld.wolfram.com/Dice.html for an explanation of this
	kMax := int(math.Floor(float64(p-n) / float64(s)))

	total := int64(0)
	sign := int64(-1)
	for k := int(0); k <= kMax; k++ {
		sign *= int64(-1)
		left := probability.ChooseHelper(n, k, cache)
		right := probability.ChooseHelper((p - s*k - 1), n-1, cache)

		term := sign * left * right
		total += term
	}

	return total
}
